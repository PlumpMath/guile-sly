* Sly

  Sly is a free software game engine written in GNU Guile Scheme.  It
  provides an abstraction layer above SDL and OpenGL for common game
  programming requirements such as:

  - Meshes
  - Shaders
  - Sprites
  - Animation
  - Tilesets
  - Scene graph
  - Keyboard/mouse input
  - Scripting

  Sly differentiates itself from other game engines by providing an
  interactive development environment via Guile's read-eval-print-loop
  (REPL), exposing a functional API instead of an object-oriented one,
  and encouraging reactive programming.

** Inspiration

   Every programming language should have a fun, easy to use game
   library.  Sly draws its inspiration from great libraries/engines
   such as [[http://love2d.org/][LÃ–VE]], [[http://pygame.org/][Pygame]], and [[http://pyglet.org/][Pyglet]].  Sly's functional reactive nature
   is heavily inspired by the [[http://elm-lang.org/][Elm]] programming language.

** Example

   Here is the simplest Sly application (so far).

   #+BEGIN_SRC scheme
     (use-modules (sly game)
                  (sly sprite)
                  (sly window))

     (define sprite
       (load-sprite "images/p1_front.png"
                    #:position #(320 240)))

     (add-hook! draw-hook (lambda (dt alpha) (draw-sprite sprite)))

     (with-window (make-window #:title "Simple Sprite Demo")
       (run-game-loop))
   #+END_SRC

** Features

*** The Game Loop

    Sly's game loop doesn't tie drawing and updating
    together. Instead, updates happen on a fixed timestep (60 ticks
    per second by default) while drawing happens as many times as
    possible. A framerate indepedent loop mitigates slow down that the
    user might experience when updating the game takes longer than
    drawing a frame at the desired rate. Instead of slowing to a
    crawl, some frames are dropped and the loop tries to catch up on
    updates. Additionally, a fixed timestep allows for a deterministic
    simulation, unlike a variable timestep.

    To start up the game loop, simply call =(start-game-loop)=. It's a
    good idea to set up the game window prior to starting the loop via
    the =with-window= form.

    #+BEGIN_SRC scheme
      (with-window (make-window #:title "Best Game Ever"
                                #:resolution #(640 480))
        (start-game-loop))
    #+END_SRC

*** Sprites

    Sprites encapsulate the presentation of an image or a region of an
    image.

    The simplest way to get started with sprites is to use the
    =load-sprite= procedure. All arguments except the filename are
    optional keyword arguments.

    Sly uses the FreeImage library and can load many different image
    formats. See the FreeImage [[http://freeimage.sourceforge.net/features.html][features page]] for a full list of
    supported formats.

    #+BEGIN_SRC scheme
      (use-modules (sly sprite))

      (define sprite
        (load-sprite "cirno.png"
                     #:position #(320 240)
                     #:scale #(1 1)
                     #:rotation 45
                     #:color white
                     #:anchor 'center))
    #+END_SRC

    Alternatively, you can make a sprite from an existing texture. The
    same keyword arguments in =load-sprite= are also available here.

    #+BEGIN_SRC scheme
      (define sprite (make-sprite (load-texture "cirno.png")))
    #+END_SRC

    Position, scale, rotation, color, and anchor are mutable.

    #+BEGIN_SRC scheme
      (set-sprite-position! sprite #(100 100))
    #+END_SRC

    Drawing a sprite is simple.

    #+BEGIN_SRC scheme
      (draw-sprite sprite)
    #+END_SRC

*** Keyboard and Mouse Input

    There are hooks within the =(sly keyboard)= and =(sly mouse)=
    modules that can be used to respond to user input.

    #+BEGIN_SRC scheme
      (use-modules (sly keyboard)
                   (sly mouse))

      ;; Quit when ESC is pressed.
      (add-hook! key-press-hook
                 (lambda (key unicode)
                   (when (eq? key 'escape)
                     (quit-game))))

      ;; Print coordinates when the mouse is moved.
      (add-hook! mouse-move-hook
                 (lambda (x y)
                   (format #t "pos: (~d, ~d)\n" x y)))
    #+END_SRC

    In the future, there will be more convenient ways to respond to
    user input similar to how keymaps work in Emacs.

*** Coroutines and the Agenda

    The ability to write scripts is very important for most games. A
    script for an RPG NPC could look like this:

    #+BEGIN_SRC scheme
      ;; Walk up one tile and then down one tile, forever.
      (while #t
        (walk 'up)
        (walk 'down))
    #+END_SRC

    Unfortunately, running this script as it is means completely
    locking up the program in an unbounded loop. However, coroutines
    (and a scheduler known as the "agenda") are here to save the day!
    Coroutines are procedures that can be exited at any point and
    resumed later.

    It would be nice if after every call to =walk=, the NPC would wait
    for one second before taking its next step. This is where the
    agenda comes in. The agenda is used to schedule procedures to be
    run after an arbitrary number of game updates (1 by
    default). Since coroutines and the agenda go hand in hand, there
    exists a =wait= procedure to pause a coroutine and schedule it to
    be resumed later.

    Using a coroutine and the agenda, the NPC script can be rewritten
    such that it does not halt further program execution.

    #+BEGIN_SRC scheme
      (use-modules (sly agenda)
                   (sly coroutine))

      (coroutine
       (while #t
         (walk 'up)
         (wait 60)
         (walk 'down)
         (wait 60)))
    #+END_SRC

    =coroutine= is a useful macro that evaluates a block of code as a
    coroutine.  =wait= aborts the procedure and schedules the
    continuation inside of the agenda.  In this example, the script is
    paused for 1 second after each step.  Since Sly enforces a fixed
    timestep and updates 60 times per second by default, 60 ticks is
    equivalent to 1 second.

    You can also use the agenda to schedule the evaluation of any
    thunk even if it isn't a coroutine.

    #+BEGIN_SRC scheme
      (define (hello)
        (display "Hello, world!  Sorry I'm late!\n"))

      (schedule hello 600)
    #+END_SRC

    =schedule= accepts a thunk (a procedure that takes no arguments)
    and schedules it to be applied after a certain number of ticks, or
    after 1 tick by default.  In this example, the text "Hello, world!
    Sorry I'm late!" is displayed after 10 seconds.  There are other
    ways to schedule procedures, too.  =schedule-interval= applies a
    thunk periodically, and =schedule-each= applies a thunk upon every
    tick.

*** Functional Reactive Programming

    Games are composed of values that evolve as time passes.  The
    player's score, the current stage, an enemy's hit points, etc. all
    change in response to events that happen at discrete points in
    time.  Typically, this means that a number of callback procedures
    are registered to react to events which mutate data structures
    and/or assign to variables.  However, this approach, while simple
    and effective, comes at the price of readability and
    comprehension.  Instead of explicitly mutating data and entering
    "callback hell", Sly abstracts and formalizes the process using a
    functional reactive programming style.

    Time-varying values are called "signals", and they are created in
    a declarative and functional manner.  Rather than describing the
    process of mutation procedurally, one describes the relationship
    between signals instead.  Signal relationships are described in a
    functional style using =signal-map=, =signal-fold=,
    =signal-filter=, and others.

    Example:
    #+BEGIN_SRC scheme
      (define-signal position
        (signal-fold v+ #(320 240)
                     (signal-map (lambda (v) (v* v 4))
                                 (signal-sample 1 key-arrows))))
    #+END_SRC

    This signal describes a relationship between the arrow keys on the
    keyboard and the position of the player.  =signal-sample= is used
    to trigger a signal update upon every game tick that provides the
    current state of the arrow keys.  =key-arrows= is a vector that
    maps to the current state of the arrow keys, allowing for 8
    direction movement.  This vector is then scaled 4x to make the
    player move faster.  Finally, the scaled vector is added to the
    previous player position via =signal-fold=.  The player's position
    is at (320, 240) initially.  As you can see, there are no
    callbacks and explicit mutation needed.  Those details have been
    abstracted away, freeing the programmer to focus on more important
    things.

    As an added bonus, signals adapt to changes in their environment
    when defined using the =define-signal= form.  This means that a
    signal can be re-defined at the REPL and other dependent signals
    will take notice and re-evaluate themselves automagically.

*** REPL Driven Development

   The read-eval-print-loop present in Guile allows you to develop
   your game while it is running! This allows you to see in real time
   what your changes do to the game without having to restart the
   program every time.

   Sly integrates Guile's cooperative REPL server with the game loop.
   To activate this feature, import the =(sly repl)= module and call
   =(start-sly-repl)=.  To connect to the REPL server, use the [[http://www.nongnu.org/geiser/][Geiser]]
   extension for GNU Emacs or telnet.

   *Geiser*

   #+BEGIN_SRC fundamental
    M-x connect-to-guile
   #+END_SRC

   Use the default host and port settings.

   *Telnet*

   #+BEGIN_SRC sh
     telnet localhost 37146
   #+END_SRC

** Building

   Sly uses the typical GNU build system. First run =autogen.sh= and
   then do the usual incantations.

   #+BEGIN_SRC sh
     ./autogen.sh
     ./configure
     make
     sudo make install
   #+END_SRC

   See =INSTALL.org= for more detailed installation instructions.

** Running Examples

   To run an example when Sly has been installed:

   #+BEGIN_SRC sh
     cd examples
     guile simple.scm
   #+END_SRC

   To run an example without installing Sly (useful when developing):

   #+BEGIN_SRC sh
     cd examples
     ../pre-inst-env guile simple.scm
   #+END_SRC

   To quit an example:
   - Close the window
   - Press the =ESCAPE= key

** Using the Sandbox

   If you want to quickly create a Sly environment and start
   experimenting, run =./pre-inst-env sandbox=.  It will import many
   useful modules, start a REPL server, open a window, and start the
   game loop.  Simply connect to the REPL server and start hacking!

** Platforms

   Sly supports GNU/Linux currently. OS X support is in the works, but
   there are problems with guile-sdl. See
   https://github.com/davexunit/guile-2d/issues/2 for more details.

** Dependencies

   - GNU Guile >= 2.0.11
   - [[http://www.gnu.org/software/guile-opengl/][guile-opengl]] >= 0.1.0
   - [[https://www.gnu.org/software/guile-sdl/index.html][guile-sdl]] >= 0.5.0
   - SDL 1.2
   - FreeImage >= 3.0

** License

   GNU GPL v3+

   See =COPYING= for the full license text.
